(function (Chart) { var helpers = Chart.helpers; var noop = helpers.noop; Chart.defaults.global.milestone_legend = { display: true, position: 'bottom', fullWidth: true, reverse: false, onClick: function (e, legendItem) { var index = legendItem.datasetIndex; var ci = this.chart; var meta = ci.getDatasetMeta(index); meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; ci.update() }, onHover: null, labels: { boxWidth: 12, padding: 10, generateLabels: function (chart) { var data = chart.data; return helpers.isArray(data.datasets) ? data.datasets.filter(function (d) { return d.type === 'milestone' }).map(function (dataset, i) { return { text: dataset.label, fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]), hidden: !chart.isDatasetVisible(i), lineCap: dataset.borderCapStyle, lineDash: dataset.borderDash, lineDashOffset: dataset.borderDashOffset, lineJoin: dataset.borderJoinStyle, lineWidth: 0, strokeStyle: dataset.borderColor, pointStyle: dataset.pointStyle, datasetIndex: i } }, this) : [] } } }; function getBoxWidth(labelOpts, fontSize) { return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth } Chart.Milestone_Legend = Chart.Element.extend({ initialize: function (config) { helpers.extend(this, config); this.legendHitBoxes = []; this.doughnutMode = false }, beforeUpdate: noop, update: function (maxWidth, maxHeight, margins) { var me = this; me.beforeUpdate(); me.maxWidth = maxWidth; me.maxHeight = maxHeight; me.margins = margins; me.beforeSetDimensions(); me.setDimensions(); me.afterSetDimensions(); me.beforeBuildLabels(); me.buildLabels(); me.afterBuildLabels(); me.beforeFit(); me.fit(); me.afterFit(); me.afterUpdate(); return me.minSize }, afterUpdate: noop, beforeSetDimensions: noop, setDimensions: function () { var me = this; if (me.isHorizontal()) { me.width = me.maxWidth; me.left = 0; me.right = me.width } else { me.height = me.maxHeight; me.top = 0; me.bottom = me.height } me.paddingLeft = 0; me.paddingTop = 0; me.paddingRight = 0; me.paddingBottom = 0; me.minSize = { width: 0, height: 0 } }, afterSetDimensions: noop, beforeBuildLabels: noop, buildLabels: function () { var me = this; me.legendItems = me.options.labels.generateLabels.call(me, me.chart); if (me.options.reverse) { me.legendItems.reverse() } }, afterBuildLabels: noop, beforeFit: noop, fit: function () { var me = this; var opts = me.options; var labelOpts = opts.labels; var display = opts.display; var ctx = me.ctx; var globalDefault = Chart.defaults.global, itemOrDefault = helpers.getValueOrDefault, fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); var hitboxes = me.legendHitBoxes = []; var minSize = me.minSize; var isHorizontal = me.isHorizontal(); if (isHorizontal) { minSize.width = me.maxWidth; minSize.height = display ? 10 : 0 } else { minSize.width = display ? 10 : 0; minSize.height = me.maxHeight } if (display) { ctx.font = labelFont; if (isHorizontal) { var lineWidths = me.lineWidths = [0]; var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; helpers.each(me.legendItems, function (legendItem, i) { var boxWidth = getBoxWidth(labelOpts, fontSize); var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width; if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) { totalHeight += fontSize + (labelOpts.padding); lineWidths[lineWidths.length] = me.left } hitboxes[i] = { left: 0, top: 0, width: width, height: fontSize }; lineWidths[lineWidths.length - 1] += width + labelOpts.padding }); minSize.height += totalHeight } else { var vPadding = labelOpts.padding; var columnWidths = me.columnWidths = []; var totalWidth = labelOpts.padding; var currentColWidth = 0; var currentColHeight = 0; var itemHeight = fontSize + vPadding; helpers.each(me.legendItems, function (legendItem, i) { var boxWidth = getBoxWidth(labelOpts, fontSize); var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width; if (currentColHeight + itemHeight > minSize.height) { totalWidth += currentColWidth + labelOpts.padding; columnWidths.push(currentColWidth); currentColWidth = 0; currentColHeight = 0 } currentColWidth = Math.max(currentColWidth, itemWidth); currentColHeight += itemHeight; hitboxes[i] = { left: 0, top: 0, width: itemWidth, height: fontSize } }); totalWidth += currentColWidth; columnWidths.push(currentColWidth); minSize.width += totalWidth } } me.width = minSize.width; me.height = minSize.height }, afterFit: noop, isHorizontal: function () { return this.options.position === 'top' || this.options.position === 'bottom' }, draw: function () { var me = this; var opts = me.options; var labelOpts = opts.labels; var globalDefault = Chart.defaults.global, lineDefault = globalDefault.elements.line, legendWidth = me.width, lineWidths = me.lineWidths; if (opts.display) { var ctx = me.ctx, cursor, itemOrDefault = helpers.getValueOrDefault, fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor), fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.lineWidth = 0.5; ctx.strokeStyle = fontColor; ctx.fillStyle = fontColor; ctx.font = labelFont; var boxWidth = getBoxWidth(labelOpts, fontSize), hitboxes = me.legendHitBoxes; var drawLegendBox = function (x, y, legendItem) { if (isNaN(boxWidth) || boxWidth <= 0) { return } ctx.save(); ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor); ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle); ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset); ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle); ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth); ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor); var isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0); if (ctx.setLineDash) { ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash)) } if (opts.labels && opts.labels.usePointStyle) { var radius = fontSize * Math.SQRT2 / 2; var offSet = radius / Math.SQRT2; var centerX = x + offSet; var centerY = y + offSet; Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY) } else { if (!isLineWidthZero) { ctx.strokeRect(x, y, boxWidth, fontSize) } ctx.fillRect(x, y, boxWidth, fontSize) } ctx.restore() }; var fillText = function (x, y, legendItem, textWidth) { ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y); if (legendItem.hidden) { } }; var isHorizontal = me.isHorizontal(); if (isHorizontal) { cursor = { x: me.left + ((legendWidth - lineWidths[0]) / 2), y: me.top + labelOpts.padding, line: 0 } } else { cursor = { x: me.left + labelOpts.padding, y: me.top + labelOpts.padding, line: 0 } } var itemHeight = fontSize + labelOpts.padding; helpers.each(me.legendItems, function (legendItem, i) { var textWidth = ctx.measureText(legendItem.text).width, width = boxWidth + (fontSize / 2) + textWidth, x = cursor.x, y = cursor.y; if (isHorizontal) { if (x + width >= legendWidth) { y = cursor.y += itemHeight; cursor.line++; x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) } } else if (y + itemHeight > me.bottom) { x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding; y = cursor.y = me.top; cursor.line++ } drawLegendBox(x, y, legendItem); hitboxes[i].left = x; hitboxes[i].top = y; fillText(x, y, legendItem, textWidth); if (isHorizontal) { cursor.x += width + (labelOpts.padding) } else { cursor.y += itemHeight } }) } }, handleEvent: function (e) { var me = this; var opts = me.options; var type = e.type === 'mouseup' ? 'click' : e.type; var changed = false; if (type === 'mousemove') { if (!opts.onHover) { return } } else if (type === 'click') { if (!opts.onClick) { return } } else { return } var position = helpers.getRelativePosition(e, me.chart.chart), x = position.x, y = position.y; if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) { var lh = me.legendHitBoxes; for (var i = 0; i < lh.length; ++i) { var hitBox = lh[i]; if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) { if (type === 'click') { opts.onClick.call(me, e, me.legendItems[i]); changed = true; break } else if (type === 'mousemove') { opts.onHover.call(me, e, me.legendItems[i]); changed = true; break } } } } return changed } }); Chart.plugins.register({ beforeInit: function (chartInstance) { var opts = chartInstance.options; var legendOpts = opts.milestone_legend; if (legendOpts) { chartInstance.milestone_legend = new Chart.Milestone_Legend({ ctx: chartInstance.chart.ctx, options: legendOpts, chart: chartInstance }); Chart.layoutService.addBox(chartInstance, chartInstance.milestone_legend) } } }) }).call(this, Chart);